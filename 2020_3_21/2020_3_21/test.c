#define _CRT_SECURE_NO_WARNINGS 1
#include "main.h"

//第一种方法：选择排序法
//用一种较为容易理解的方法实现选择排序

void select_Sort1(int a[], int n)
{
	int i, j, k;
	//外部循环从小到大，依次找出各位置上的值（最后一个位置上的值除外，因为在循环的过程中各个位置上的值逐渐确定下来，最后一个值自然就确定了）
	for (i = 0; i < n - 1; i++)
	{
		//内部循环从外部循环指针的下一个位置开始，将后续位置上取到的值逐渐与外部循环所对应的指针上的值进行比较
		for (j = i + 1; j < n; j++)
		{
			if (a[j] < a[i])
			{
				// 找到比该位置上的值小的值就进行一次交换 
				k = a[i];
				a[i] = a[j];
				a[j] = k;
			}
		}
	}
}

//以下方法实现起来效率更高，之所以效率高是因为找到一个比外循环指针所对应值更小的值时没有马上交换而是把位置先记录下来，内循环结束后再交换

void select_Sort2(int a[], int n)
{
	int i, j, k, t;
	//外部循环从小到大，依次找出各位置上的值（最后一个位置上的值除外，因为在循环的过程中各个位置上的值逐渐确定下来，最后一个值自然就确定了） 
	for (i = 0; i < n - 1; i++)
	{
		//内部循环从外部循环指针的下一个位置开始，将后续位置上取到的值逐渐与外部循环所对应的指针上的值进行比较
		k = i;//k的作用是记录内部指针一趟比较下来，哪个位置所对应的值比外指针所对应的值小，将该位置存放到k中，默认情况下k的值是外指针对应位置
		for (j = i + 1; j < n; j++)
		{
			if (a[j] < a[k])
				k = j;//k=j 记录下最小值的位置 
		}
		//进行交换，t是临时变量 
		t = a[i];
		a[i] = a[k];
		a[k] = t;
	}
}

//第二种方法：冒泡排序法 

void bubble_Sort(int a[], int n)
{
	int i, j, t;
	//外层循环控制圈数，对n个数排序，需要n-1圈
	//外层循环指针对应将要放数的位置，每次结束外层循环都将排好了一个数
	for (i = n - 1; i > 0; i--)
	{
		//内层循环对相邻的俩个数进行比较，大者冒泡到后边，j<i使得内层循环不必再对已经排好的数进行访问 
		for (j = 0; j < i; j++)
		{
			if (a[j] > a[j + 1])
			{
				t = a[j];
				a[j] = a[j + 1];
				a[j + 1] = t;
			}
		}
	}
}

//第三种方法：插入法排序 

void insert_Sort(int a[], int n)
{
	int i, j, t;
	//外层循环的作用是从0位置开始逐渐从数组中将n个数拿出来，与已经排好的数进行比较，插入到适当的位置
	for (i = 0; i < n; i++)
	{
		//对已有的数（这些数已经排好）逐一与外层循环拿出的数进行比较
		//之所以j=i-1是因为i代表进行插入排序的数的位置，j就表示了排好序以后该有序数列最后一个数的位置
		for (j = i - 1; j >= 0; j--)
		{
			if (a[j + 1] < a[j])
			{
				t = a[j + 1];
				a[j + 1] = a[j];
				a[j] = t;
			}
		}
	}
}